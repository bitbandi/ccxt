# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError


class inlock(Exchange):

    def describe(self):
        return self.deep_extend(super(inlock, self).describe(), {
            'id': 'inlock',
            'name': 'InLock.io',
            'countries': ['HU'],
            'rateLimit': 20,
            'version': 'v1.0',
            'userAgent': self.userAgents['chrome'],
            'has': {
                'CORS': None,
                'spot': True,
                'margin': None,
                'swap': None,
                'future': None,
                'option': None,
                'fetchBalance': True,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/51840849/87460810-1dd06c00-c616-11ea-9276-956f400d6ffa.jpg',
                'api': 'https://api.inlock.io/inlock/api',
                'www': 'https://inlock.io',
                'doc': 'https://app.swaggerhub.com/apis/IncomeLocker/inlock_retail_api/',
            },
            'api': {
                'retail': {
                    'get': [
                        'getBalance',
                    ],
                },
            },
            'markets': {
            },
        })

    def parse_balance(self, response):
        result = {
            'info': response,
        }
        balances = response.coins
        for i in range(0, len(balances)):
            balance = balances[i]
            symbol = self.safe_string(balance, 'ticker')
            code = self.safe_currency_code(symbol)
            account = self.account()
            account['total'] = self.safe_string(balance, 'balance')
            account['used'] = self.safe_string(balance, 'locked')
            result[code] = account
        return self.safe_balance(result)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.retailGetGetBalance(params)
        balances = self.safe_value(response['result'], 'getBalance')
        return self.parse_balance(balances)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        query = self.omit(params, self.extract_params(path))
        print(query)
        url = self.urls['api'] + '/' + self.version + '/' + api + '/' + path
        # FIXME: implement self right
        if method == 'GET':
            if params:
                url += '?' + self.urlencode(params)
        else:
            body = self.urlencode(params)
        self.check_required_credentials()
        raw_data = url
        signature = self.binary_to_base58(self.hmac(raw_data, self.base58_to_binary(self.secret), hashlib.sha512, None))
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-Apikey': self.apiKey,
            'X-Signature': signature,
        }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if 'error' in response:
            # errorCode = self.safe_string(response['error'], 'code')
            message = self.safe_string(response['error'], 'message')
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message
